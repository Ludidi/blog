# 重排和回流

## 区别

- 重绘（Repaint）：当一个元素的外观发生了改变，但没有改变布局，重新把元素的外观绘制出来，叫做重绘。表现为某些元素的外观被改变
- 重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面的正确位置，找个过程叫做重排，表现为重新生成布局，重新排列元素

> 重绘不一定会出现重排，但重排必然会出现重绘

> 重绘和重排代价是高昂的，他们会破坏用户体验，并且让 ui 展示缓慢，而相比之下的重排影响性能更大，在两者无法避免的情况下，最好选择代价更下的重绘

## 如何触发重绘和重排

触发重排：

- 页面初始化渲染
- 添加/删除可见的 DOM 元素
- 改变元素位置
- 改变元素尺寸，比如边距、填充、边框、宽度和高度等
- 改变元素内容
- 改变元素字体大小
- 改变浏览器窗口尺寸，浏览器滚动
- 激活 CSS 伪类
- 设置 style 属性的值，因为通过设置 style 属性改变节点样式，每次设置都会触发一次 reflow
- 查询某些属性或者调用某些计算方法，如 getComputedStyle

## 如何避免重绘和重排

- 尽量减少重排的范围，尽可能在修改低层级的布局，尽量不要影响全局的范围
- 尽量减少使用 table 布局。如果一定要用 table 时，可以设置 table-layout:auto 或者是 table-layout:fixed 可以让 table 一行一行的渲染，尽量限制 reflow 的影响范围
- 样式集中改变
- 分离读写操作，多个读或者多个写应该放在一起
- DOM 隐藏
  - display:none，一旦设置 none 时，只会触发一次重排重绘，元素便不会再渲染树中，相当于将其从页面中拿掉，之后再对元素做样式修改后再显示，这样只会触发两次重排。
  - visibility:hidden 的元素只对重绘有影响，不影响重排
  - 通过 documentFragment 创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排
  - 复制节点，在副本上工作，然后再替换
- 使用 absolute 或者 fixed
- 动画采用 GPU 加速，translate 使用 3d 变化
- 提升为合成层，合成层的位图都会交由 GPU 合成，比 CPU 处理要快，可采用 css 的 will-change: transform
