# 时间复杂度和空间复杂度

## 时间复杂度

> 时间纬度： 是指执行当前算法所消耗的时间，通常用【时间复杂度】描述

如果想要知道一个算法的时间复杂度，首先想到的是把这个算法程序运行一遍，那么他消耗的时间自然而然就知道了。但其实这种方式有很多的弊端，非常容易受到运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。

因此有一种通用的方法【大**O**符号表示法】，即`T(n) = O(f(n))`

示例：

```javascript
for (i = i; i < n; ++i) {
  j = i;
  j++;
}
```

通过【大**O**符号表示法】这段代码的时间复杂度为: O(n)，在表示法中，时间复杂度的公式为 T(n) = O(f(n))。其中 f(n)表示每行代码执行的次数，而 O 表示正比列关系，这个公式的全称为：算法的渐进时间复杂度

假设上面的例子每行代码的执行时间都是一样的，我们用 1 颗粒度来表示，那么这个例子的第一行耗时是 1 个颗粒度时间，第三行执行的时间是 n 个颗粒度，第四行执行的时间也是 n 个颗粒时间（第二行和第五行是符号，可以忽略），那么总时间就是 1 颗粒度时间 + n 颗粒度时间，即(1+2n)个颗粒度时间，即 T(n) = (1+2n)\*颗粒度时间，从这个结果来看，这个算法的耗时是随着 n 的变化而变化的，因此，我们可以简化这个算法的时间复杂度为 T(n) = O(n)

为什么会这样简化呢，因为大 O 符号表示法并不是用于真实代表算法的执行时间的，它是用来表示**代码执行时间的增长变化趋势**的。所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+2n)中的常量 1 就没有意义了，倍数 2 意义也不大，因此简化为 T(n) = O(n)。

常见的时间复杂度量级有:

- 常数阶 O(1)
- 对数阶 O(logN)
- 线性阶 O(n)
- 线性对数阶 o(nlogN)
- 平方阶 O(n²)
- 立方阶 O(n³)
- K 次方阶 O(n^k)
- 指数阶 O(2^n)

从上至下一次的时间复杂度越来越大，执行的效率会越来越低

### 1.常数阶 O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那么这个代码的时间复杂度都是 O(1)

```javascript
var i = 1;
var j = 2;
++i;
++j;
var m = i + j;
```

上面代码在执行的时候，它消耗的并不是随着某个变量的增长而增长，那么无论这个类代码有多长都可以用 O(1)来表示它的时间复杂度

### 2.对数阶 O(longN)

```javascript
var i = 1;
while (1 < n) {
  i = i * 2;
}
```

在 while 循环里面，每次都将 i \* 2，乘完后，i 距离 n 就越来越近。假设循环 x 次之后，i 就大于 n 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x=log2n。也就是说当循环 log2n 次以后，这个代码就结束了，因此这个代码的时间复杂度为 O(logN)

### 3.线性对数阶 O(nlogN)

将时间复杂度 O(lngN)循环 N 遍，那么它就是 O(nlogN)

```javascript
for (var m = 1; m < n; ++m) {
  i = 1;
  while (i < n) {
    i = i * 2;
  }
}
```

### 4.平方阶 O(n²)

如果把 O(n)的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)

```javascript
for (x = 1; i <= n; x++) {
  for (i = 1; i <= n; i++) {
    j = i;
    j++;
  }
}
```

为 O(n\*n)，即为 O(n²)

如果将其中一个 n 改为 m，则就是 O(m\*n)

### 5.立方阶 O(n³)

相当于 3 层 n 循环

## 空间复杂度

> 空间维度： 指执行当前算法需要占用多少内存空间，通常用【空间复杂度】描述

常用的有 O(1)、O(n)、O(n²)

### 1.空间复杂度 O(1)

**算法执行所需要的临时空间不随着某个变量 n 的大小而变化**，即此算法空间复杂度为一个常量，可表示为 O(1)

```javascript
var i = 1;
var j = 2;
++i;
++j;
var m = i + j;
```

代码中的 i、j、m 所分配的空间都不会随着处理数据量变化，因此他们的空间复杂度是 S(n) = O(1)

### 2.空间复杂度 O(n)

```javascript
var arr = new Array(n);
for (var i = 1; i <= n; ++i) {
  var j = i;
  j++;
}
```
